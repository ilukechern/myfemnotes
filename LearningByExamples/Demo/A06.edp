// NBPROC 1
// PARAM -v 0 -wg -ns -ksp_monitor
load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

mesh ThGlobal = square(100, 100);
mesh Th = square(100, 100);
func Pk = [P1,P1,P1];
fespace WhGlobal(ThGlobal, Pk);
fespace VhGlobal(ThGlobal, P1);
WhGlobal [uG, uGx, uGy] = [x^2, y^2, x^2+y^2];
VhGlobal pG = x + y;
int[int] n2o;
macro ThN2O()n2o//
buildDmesh(Th);
fespace Wh(Th, Pk);
fespace Vh(Th, P1);
Wh [u, ux, uy] = [x^2, y^2, x^2+y^2];
Vh p = x + y;
int[int] restWh = restrict(Wh, WhGlobal, n2o);
int[int] restVh = restrict(Vh, VhGlobal, n2o);
{
    macro def(i)[i, i#B, i#C]//
    macro init(i)[i, i, i]//

    Mat A;
    createMat(Th, A, Pk); // trick => use P2, not P2Morley!
    real[int] tmp;
    ChangeNumbering(A, u[], tmp);
    ChangeNumbering(A, u[], tmp, inverse = true);
    WhGlobal [reducex, reducey, reducez];
    WhGlobal [beforex, beforey, beforez];
    for[i, v : restWh] beforex[][v] = u[][i];
    mpiReduce(beforex[], reducex[], processor(0, mpiCommWorld), mpiSUM);
    uG[] -= reducex[];
    if(mpirank == 0) assert(uG[].l2 < 1.0e-12);
}

{
    Mat A;
    createMat(Th, A, P1);
    real[int] tmp;
    ChangeNumbering(A, p[], tmp);
    ChangeNumbering(A, p[], tmp, inverse = true);
    VhGlobal reduce;
    VhGlobal before;
    before[] = 0;
    for[i, v : restVh] before[][v] = p[][i];
    mpiReduce(before[], reduce[], processor(0, mpiCommWorld), mpiSUM);
    pG[] -= reduce[];
    if(mpirank == 0) assert(pG[].l2 < 1.0e-12);
}